const std = @import("std");

const Self = @This();
// const GlobalContext = @import("./GlobalContext.zig");

const ThreadInstance = struct {
    memory: []u8,
    wrapper_ptr: usize,
    entry: *const fn (usize) void,
    original_stack_ptr: [*]u8,
    stack_offset: usize,
    allocator: std.mem.Allocator,
};

const ThreadConfig = struct {
    stack_size: usize = 1024 * 1024, // 1MB
    allocator: std.mem.Allocator,
};

pub const StartThreadError = error{
    OutOfMemory,
};

pub fn spawn(
    config: ThreadConfig,
    comptime start: anytype,
    args: anytype,
) StartThreadError!void {
    comptime {
        const arg_ti = @typeInfo(@TypeOf(args));
        switch (arg_ti) {
            .Struct => {},
            else => @compileError("Unsupported argument type for thread start function"),
        }
    }

    // const g = GlobalContext.current();

    const Wrapper = struct {
        args: @TypeOf(args),
        fn entry(ptr: usize) void {
            const w: *@This() = @ptrFromInt(ptr);
            switch (@typeInfo(@typeInfo(@TypeOf(start)).Fn.return_type.?)) {
                .NoReturn, .Void => {
                    @call(.auto, start, w.args);
                },
                else => {
                    @compileError("Unsupported return type for thread start function");
                },
            }
        }
    };

    var stack_offset: usize = 0;
    var wrapper_offset: usize = 0;
    var instance_offset: usize = 0;

    const map_bytes = blk: {
        var bytes: usize = std.mem.page_size;

        bytes = std.mem.alignForward(usize, bytes, 16);
        bytes += @max(std.mem.page_size, config.stack_size);
        stack_offset = bytes;

        bytes = std.mem.alignForward(usize, bytes, @alignOf(Wrapper));
        wrapper_offset = bytes;
        bytes += @sizeOf(Wrapper);

        bytes = std.mem.alignForward(usize, bytes, @alignOf(ThreadInstance));
        instance_offset = bytes;
        bytes += @sizeOf(ThreadInstance);

        bytes = std.mem.alignForward(usize, bytes, std.mem.page_size);

        break :blk bytes;
    };

    const allocator = config.allocator;

    const allocated_memory = try allocator.alloc(u8, map_bytes);

    const wrapper: *Wrapper = @ptrCast(@alignCast(&allocated_memory[wrapper_offset]));
    wrapper.* = .{
        .args = args,
    };

    const instance: *ThreadInstance = @ptrCast(@alignCast(&allocated_memory[instance_offset]));
    instance.* = .{
        .allocator = config.allocator,
        .memory = allocated_memory,
        .wrapper_ptr = @intFromPtr(wrapper),
        .entry = &Wrapper.entry,
        .original_stack_ptr = __get_stack_pointer(),
        .stack_offset = stack_offset,
    };

    startWorker.*(instance);
}

const lib_name = "web_worker";

fn extern_fn(comptime T: type, comptime name: []const u8) T {
    return @extern(T, .{
        .library_name = lib_name,
        .name = name,
    });
}

const startWorker = extern_fn(
    *const fn (*ThreadInstance) callconv(.C) void,
    "start",
);

export fn __wasm_threadStart(instance: *ThreadInstance) void {
    __set_stack_pointer(instance.memory.ptr + instance.stack_offset);
    instance.entry(instance.wrapper_ptr);
    __set_stack_pointer(instance.original_stack_ptr);
    const alloc = instance.allocator;
    alloc.free(instance.memory);
}

/// Initializes the TLS data segment starting at `memory`.
/// This is a synthetic function, generated by the linker.
// extern fn __wasm_init_tls(memory: [*]u8) void;

/// Returns a pointer to the base of the TLS data segment for the current thread
inline fn __tls_base() [*]u8 {
    return asm (
        \\ .globaltype __tls_base, i32
        \\ global.get __tls_base
        \\ local.set %[ret]
        : [ret] "=r" (-> [*]u8),
    );
}

/// Returns the size of the TLS segment
inline fn __tls_size() u32 {
    return asm volatile (
        \\ .globaltype __tls_size, i32, immutable
        \\ global.get __tls_size
        \\ local.set %[ret]
        : [ret] "=r" (-> u32),
    );
}

/// Returns the alignment of the TLS segment
inline fn __tls_align() u32 {
    return asm (
        \\ .globaltype __tls_align, i32, immutable
        \\ global.get __tls_align
        \\ local.set %[ret]
        : [ret] "=r" (-> u32),
    );
}

/// Allows for setting the stack pointer in the WebAssembly module.
inline fn __set_stack_pointer(addr: [*]u8) void {
    asm volatile (
        \\ local.get %[ptr]
        \\ global.set __stack_pointer
        :
        : [ptr] "r" (addr),
    );
}

/// Returns the current value of the stack pointer
inline fn __get_stack_pointer() [*]u8 {
    return asm (
        \\ global.get __stack_pointer
        \\ local.set %[stack_ptr]
        : [stack_ptr] "=r" (-> [*]u8),
    );
}
