const std = @import("std");
const Self = @This();
const GlobalContext = @import("./GlobalContext.zig");

extern "js" fn __sysGetCoreCount() u16;

extern "js" fn __consoleLog(s: [*]const u8, sLen: usize) void;

pub inline fn log(s: []const u8) void {
    __consoleLog(s.ptr, s.len);
}

pub inline fn cpuCount() u16 {
    return __sysGetCoreCount();
}

const ThreadInstance = struct {
    memory: []u8,
    data_ptr: usize,
    entry: *const fn (usize) void,
    original_stack_ptr: [*]u8,
    stack_offset: usize,
};

pub const StartThreadError = error{
    OutOfMemory,
};

pub fn startThread(comptime start: anytype, args: anytype) StartThreadError!void {
    comptime {
        const arg_ti = @typeInfo(@TypeOf(args));
        switch (arg_ti) {
            .Struct => {},
            else => @compileError("Unsupported argument type for thread start function"),
        }
    }
    // const g = GlobalContext.current();
    // const idx = g.thread_idx;
    // g.thread_idx += 1;

    const g = GlobalContext.current();

    const Wrapper = struct {
        args: @TypeOf(args),
        fn entry(ptr: usize) void {
            const w: *@This() = @ptrFromInt(ptr);
            switch (@typeInfo(@typeInfo(@TypeOf(start)).Fn.return_type.?)) {
                .NoReturn, .Void => {
                    @call(.auto, start, w.args);
                },
                else => {
                    @compileError("Unsupported return type for thread start function");
                },
            }
        }
    };

    const thread_stack_size = 1024 * 1024; // 1MB

    var stack_offset: usize = 0;
    var wrapper_offset: usize = 0;
    var instance_offset: usize = 0;

    const map_bytes = blk: {
        var bytes: usize = std.mem.page_size;

        bytes = std.mem.alignForward(usize, bytes, 16);
        bytes += @max(std.mem.page_size, thread_stack_size);
        stack_offset = bytes;

        bytes = std.mem.alignForward(usize, bytes, @alignOf(Wrapper));
        wrapper_offset = bytes;
        bytes += @sizeOf(Wrapper);

        bytes = std.mem.alignForward(usize, bytes, @alignOf(ThreadInstance));
        instance_offset = bytes;
        bytes += @sizeOf(ThreadInstance);

        bytes = std.mem.alignForward(usize, bytes, std.mem.page_size);

        break :blk bytes;
    };

    const allocator = std.heap.wasm_allocator;

    const allocated_memory = try allocator.alloc(u8, map_bytes);

    const wrapper: *Wrapper = @ptrCast(@alignCast(&allocated_memory[wrapper_offset]));
    wrapper.* = .{
        .args = args,
    };

    const instance: *ThreadInstance = @ptrCast(@alignCast(&allocated_memory[instance_offset]));
    instance.* = .{
        .memory = allocated_memory,
        .data_ptr = @intFromPtr(wrapper),
        .entry = &Wrapper.entry,
        .original_stack_ptr = __get_stack_pointer(),
        .stack_offset = stack_offset,
    };

    __workerStart(
        g,
        instance,
    );
}

extern "js" fn __workerStart(global_context_ptr: *GlobalContext, instance_ptr: *ThreadInstance) void;

export fn __threadStartCallback(global_context_ptr: *GlobalContext, instance_ptr: *ThreadInstance) void {
    __set_stack_pointer(instance_ptr.memory.ptr + instance_ptr.stack_offset);
    GlobalContext.setCurrent(global_context_ptr);
    instance_ptr.entry(instance_ptr.data_ptr);
}

/// Initializes the TLS data segment starting at `memory`.
/// This is a synthetic function, generated by the linker.
// extern fn __wasm_init_tls(memory: [*]u8) void;

/// Returns a pointer to the base of the TLS data segment for the current thread
inline fn __tls_base() [*]u8 {
    return asm (
        \\ .globaltype __tls_base, i32
        \\ global.get __tls_base
        \\ local.set %[ret]
        : [ret] "=r" (-> [*]u8),
    );
}

/// Returns the size of the TLS segment
inline fn __tls_size() u32 {
    return asm volatile (
        \\ .globaltype __tls_size, i32, immutable
        \\ global.get __tls_size
        \\ local.set %[ret]
        : [ret] "=r" (-> u32),
    );
}

/// Returns the alignment of the TLS segment
inline fn __tls_align() u32 {
    return asm (
        \\ .globaltype __tls_align, i32, immutable
        \\ global.get __tls_align
        \\ local.set %[ret]
        : [ret] "=r" (-> u32),
    );
}

/// Allows for setting the stack pointer in the WebAssembly module.
inline fn __set_stack_pointer(addr: [*]u8) void {
    asm volatile (
        \\ local.get %[ptr]
        \\ global.set __stack_pointer
        :
        : [ptr] "r" (addr),
    );
}

/// Returns the current value of the stack pointer
inline fn __get_stack_pointer() [*]u8 {
    return asm (
        \\ global.get __stack_pointer
        \\ local.set %[stack_ptr]
        : [stack_ptr] "=r" (-> [*]u8),
    );
}

// fn wasm_workerStart(global_context_ptr: *GlobalContext, function: *const fn (?*anyopaque) void, data_ptr: ?*anyopaque, idx: u32) void {
//     _ = idx; // autofix
//     Env.log("zig: __wasm_workerStart");
//     GlobalContext.setCurrent(global_context_ptr);
//     function(data_ptr);
// }

// pub export fn __wasm_workerStart(global_context_ptr: *GlobalContext, function: *const anyopaque, data_ptr: ?*anyopaque, idx: u32) void {
//     // __set_stack_pointer(@ptrFromInt(sp + 0x10_0000 * idx));
//     @call(
//         std.builtin.CallModifier.never_inline,
//         wasm_workerStart,
//         .{ global_context_ptr, @as(*const fn (?*anyopaque) void, @ptrCast(function)), data_ptr, idx },
//     );
// }
